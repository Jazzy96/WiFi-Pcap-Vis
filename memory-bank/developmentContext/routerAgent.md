# Router-Side Capture Agent: Implementation Details

## 1. Overview

The Router-Side Capture Agent is responsible for running on the target Linux-based router (QSDK environment), receiving control commands from the PC-side analysis engine via gRPC, capturing 802.11 raw frames using `tcpdump`, and streaming these frames back to the PC engine.

## 2. Chosen Language and Libraries

*   **Language:** Go (Golang)
*   **gRPC Library:** `google.golang.org/grpc`
*   **Protobuf Library:** `google.golang.org/protobuf`

**Rationale for Go:**
*   Suitable for embedded environments due to its small binary size and efficient performance.
*   Excellent built-in support for concurrency (goroutines and channels), which is useful for managing `tcpdump` processes and gRPC streams.
*   Strong standard library.
*   Good gRPC tooling and library support.

## 3. gRPC Service Definition (`.proto` file)

The gRPC service is defined in `router_agent/capture_agent.proto`:

```protobuf
syntax = "proto3";

package router_agent;

option go_package = ".;main"; // Ensures Go package is 'main' for the executable

// 控制指令类型
enum ControlCommandType {
  UNKNOWN_COMMAND = 0;
  START_CAPTURE = 1;
  STOP_CAPTURE = 2;
  SET_CHANNEL = 3; // 未来使用
  SET_BANDWIDTH = 4; // 未来使用
}

// 控制指令消息
message ControlRequest {
  ControlCommandType command_type = 1;
  string interface_name = 2; // e.g., "ath1"
  int32 channel = 3;         // e.g., 1, 6, 11, 36, 149
  string bandwidth = 4;      // e.g., "HT20", "HT40", "VHT80"
  string bpf_filter = 5;     // BPF filter string for tcpdump
}

// 控制指令响应
message ControlResponse {
  bool success = 1;
  string message = 2;
}

// 抓包数据消息
message CaptureData {
  bytes frame = 1; // 原始帧数据 (包含Radiotap)
}

// gRPC 服务定义
service CaptureAgent {
  // PC端发送控制指令给路由器代理
  rpc SendControlCommand(ControlRequest) returns (ControlResponse);

  // 路由器代理向PC端流式发送抓包数据
  rpc StreamPackets(ControlRequest) returns (stream CaptureData);
}
```

**Key RPC Methods:**
*   `SendControlCommand`: A unary RPC for the PC client to send control commands (start/stop capture, set parameters) to the router agent.
*   `StreamPackets`: A server-streaming RPC where the router agent streams captured packet data back to the PC client. The client initiates this stream.

## 4. Core Logic Explanation (`router_agent/main.go`)

The core logic is implemented in `router_agent/main.go`, which is now part of `package main` and serves as the entry point for the executable.

**Key Components:**
*   **`server` struct:** Implements the `CaptureAgentServer` interface generated by gRPC. It manages:
    *   The `tcpdump` command (`*exec.Cmd`).
    *   The pipe for reading `tcpdump`'s standard output (`io.ReadCloser`).
    *   Capture state (`isCapturing`, `currentInterface`, etc.).
    *   A mutex (`sync.Mutex`) for synchronizing access to shared state.
*   **`SendControlCommand` method:**
    *   Handles `START_CAPTURE`:
        *   Checks if a capture is already running.
        *   Validates `interface_name`.
        *   Constructs and starts the `tcpdump` command (e.g., `tcpdump -i ath1 -U -w - <bpf_filter>`).
            *   `-U`: Flushes output buffer after each packet (important for real-time streaming).
            *   `-w -`: Writes packet data to standard output.
        *   Sets up a pipe to read from `tcpdump`'s stdout.
        *   Updates capture state.
    *   Handles `STOP_CAPTURE`:
        *   Checks if a capture is running.
        *   Sends `SIGINT` to the `tcpdump` process for graceful termination. If `SIGINT` fails, `SIGKILL` is attempted.
        *   Waits for the `tcpdump` process to exit and cleans up resources.
        *   Updates capture state.
    *   `SET_CHANNEL` and `SET_BANDWIDTH` are placeholders for future implementation using `iw` commands.
*   **`StreamPackets` method:**
    *   This method is called by the client to initiate the packet stream.
    *   It waits until a capture is started (via `SendControlCommand`) and the `tcpdump` output pipe is available.
    *   Once active, it continuously reads data from the `tcpdump` pipe in a loop:
        *   Reads data into a buffer.
        *   Sends the buffered data as a `CaptureData` message over the gRPC stream.
        *   Checks for client disconnection (stream context done) or if the capture has been stopped.
        *   Handles `io.EOF` from the pipe, which typically indicates `tcpdump` has exited.
*   **`setInterfaceParams` (Helper, Future Use):**
    *   A placeholder function to demonstrate how `iw dev <iface> set channel <channel> [bandwidth]` could be called.
*   **`main()` function (in `router_agent/main.go`):**
    *   This function initializes and starts the gRPC server. Since `router_agent/main.go` is now `package main`, it directly forms the executable.
    *   The gRPC server listens on a configurable port (default `:50051`).

## 5. Compilation and Running

**Prerequisites on Router:**
*   `tcpdump` utility installed and in PATH.
*   `iw` utility (if channel/bandwidth setting is to be used, currently placeholder).
*   The wireless interface (e.g., `ath1`) should be configurable for Monitor Mode.

**Compilation Steps (on Development Machine, within `router_agent/` directory):**

1.  **Ensure Protobuf Definitions are Correct:**
    *   Verify `capture_agent.proto` has `option go_package = ".;main";`.
2.  **Generate Go code from Protobuf (if changed or first time):**
    ```bash
    protoc --go_out=. --go_opt=paths=source_relative \
           --go-grpc_out=. --go-grpc_opt=paths=source_relative \
           capture_agent.proto
    ```
3.  **Verify `go.mod` Settings:**
    *   Ensure `go` version is `1.20` or higher (e.g., `go 1.20`).
    *   Ensure `google.golang.org/grpc` is `v1.64.0` or higher.
    *   Ensure `google.golang.org/protobuf` is a compatible recent version (e.g., `v1.33.0`).
4.  **Tidy Go Modules:**
    ```bash
    go mod tidy
    ```
5.  **Cross-Compile for Target (Linux ARM64):**
    ```bash
    GOOS=linux GOARCH=arm64 go build -o router_agent_arm64 .
    ```
    This command builds the `main` package in the current directory (`router_agent/`) into an executable named `router_agent_arm64`.

**Running the Agent (on the Router):**

1.  **Transfer the Executable:**
    Copy the compiled `router_agent_arm64` binary to the router (e.g., using `scp`).
    ```bash
    scp router_agent_arm64 USER@ROUTER_IP:/path/on/router/
    ```
2.  **Make it Executable:**
    On the router, via SSH:
    ```bash
    chmod +x /path/on/router/router_agent_arm64
    ```
3.  **Run the Agent:**
    ```bash
    /path/on/router/router_agent_arm64
    ```
    Optionally, set the port via environment variable:
    ```bash
    CAPTURE_AGENT_PORT=60051 /path/on/router/router_agent_arm64
    ```

## 6. Challenges and Solutions/Considerations

*   **`protoc` Not Found:** Initially, `protoc` command was not found.
    *   **Solution:** Manually provided the generated `.pb.go` and `_grpc.pb.go` files. For a real development setup, ensuring `protoc`, `protoc-gen-go`, and `protoc-gen-go-grpc` are installed and in PATH is crucial.
*   **Go Module and Package Structure for Executable:**
    *   **Challenge:** Initial `undefined` errors during compilation (`GOOS=linux GOARCH=arm64 go build -o router_agent_arm64 main.go`) due to `main.go` containing `func main()` but being declared as `package router_agent`, while protobuf files were also `package router_agent`.
    *   **Solution:**
        1.  Modified `router_agent/main.go` to be `package main`.
        2.  Updated `router_agent/capture_agent.proto`'s `option go_package` from `".;router_agent"` to `".;main"`.
        3.  Re-generated protobuf files (`capture_agent.pb.go`, `capture_agent_grpc.pb.go`), which then correctly became `package main`.
        4.  This resolved the `undefined` type errors as all necessary code for the executable now resides within `package main`.
*   **Dependency Management (Go Version and gRPC/Protobuf Versions):**
    *   **Challenge 1 (Go Version):** Generated protobuf code (`capture_agent.pb.go`) used `unsafe.StringData`, requiring Go 1.20+, while `go.mod` specified `go 1.18`.
    *   **Solution 1:** Updated `go 1.18` to `go 1.20` in `router_agent/go.mod`.
    *   **Challenge 2 (gRPC Version):** Generated gRPC code (`capture_agent_grpc.pb.go`) required `google.golang.org/grpc v1.64.0+` (indicated by `grpc.SupportPackageIsVersion9`), but `go.mod` had `v1.50.0`.
    *   **Solution 2:** Updated `google.golang.org/grpc` to `v1.64.0` and `google.golang.org/protobuf` to `v1.33.0` in `router_agent/go.mod`.
    *   **Final Step:** Ran `go mod tidy` to synchronize dependencies.
*   **`tcpdump` Process Management:**
    *   Ensuring `tcpdump` starts correctly and its output is piped.
    *   Gracefully stopping `tcpdump` using `SIGINT`.
    *   Handling `io.EOF` from the `tcpdump` pipe.
*   **Error Handling in gRPC Streams:**
    *   Checking `stream.Context().Err()` to detect client disconnections.
*   **Cross-Compilation for Router (Specific Issues):**
    *   **Challenge 1 (Incorrect GOARCH):** Initial attempts used `GOARCH=aarch64`, which is not a valid Go value, leading to `go: unsupported GOOS/GOARCH pair linux/aarch64`.
    *   **Solution 1:** Corrected to `GOARCH=arm64` for 64-bit ARM targets.
    *   **Challenge 2 (Build Command):** After resolving package and version issues, the correct build command within the `router_agent` directory (now `package main`) is `GOOS=linux GOARCH=arm64 go build -o router_agent_arm64 .`.
*   **Interface Configuration (`iw`):**
    *   The current implementation assumes `ath1` is already in Monitor Mode. The `setInterfaceParams` function is a placeholder. Robustly handling interface mode, channel, and bandwidth settings via `iw` commands requires careful error checking and parsing of `iw` output, which can vary.
*   **Buffering and Performance:**
    *   `bufio.NewReaderSize` is used for reading `tcpdump` output. The buffer size (`65536` bytes) can be tuned.
    *   The efficiency of streaming raw packet data needs to be considered, especially on resource-constrained routers.

## 7. Future Considerations

*   Implement a proper `main` package for the executable.
*   Complete the `setInterfaceParams` function for dynamic channel/bandwidth setting.
*   Add more robust error handling and logging.
*   Implement unit and integration tests.
*   Consider security aspects if the gRPC port is exposed (e.g., TLS).
---
### gRPC Service Name Issue with PC Analysis Engine (2025-05-07)

**Context:** The PC Analysis Engine (gRPC client) reported an "Unimplemented" error (`unknown service router_agent_pb.CaptureAgent`) when attempting to communicate with this Router Agent (gRPC server).

**Analysis of Router Agent gRPC Setup:**
*   The `router_agent/capture_agent.proto` file defines:
    *   `package router_agent;`
    *   `service CaptureAgent { ... }`
    *   `option go_package = ".;main";`
*   This configuration means the Go gRPC code generated for the server (e.g., `capture_agent_grpc.pb.go` placed in the `router_agent` directory) belongs to the `main` package.
*   The `RegisterCaptureAgentServer` function, when called in `router_agent/main.go`, correctly registers the service with the gRPC runtime under the name `router_agent.CaptureAgent`. This service name is derived from the protobuf `package` and `service` declarations.

**Root Cause of Client Error:**
The issue was traced to the client-side (`pc_analyzer`) gRPC code generation:
*   The client's `pc_analyzer/capture_agent.proto` also had `package router_agent;` but its `option go_package` was `"...;router_agent_pb"`.
*   This discrepancy caused the client's generated gRPC stubs to incorrectly use `router_agent_pb.CaptureAgent` as the service name when making calls, instead of the correct `router_agent.CaptureAgent`.

**Resolution (Client-Side Fix):**
The fix was applied to the `pc_analyzer/capture_agent.proto` file by changing its `go_package` option to `"...;router_agent"`. This ensures that the client's regenerated gRPC code will use the correct service name (`router_agent.CaptureAgent`), matching what the Router Agent server registers.

**Implications for Router Agent:**
*   No changes were required for the Router Agent's code or `.proto` file itself regarding this specific issue, as its gRPC service registration was correct.
*   This incident highlights the importance of consistent `package` and `go_package` (specifically the package name part) usage across client and server `.proto` files to ensure correct service name resolution in gRPC Go.